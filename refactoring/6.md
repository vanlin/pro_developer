## 重新组织函数

在重构的世界里，几乎所有的问题都源于过长的函数导致的，因为：
- 过长的函数包含太多信息，承担太多职责，无法或者很难复用
- 错综复杂的逻辑，导致没人愿意去阅读代码，理解作者的意图

对于过长函数的处理方式，在 《重构》中作者推荐如下手法进行处理：

### Extract Method 提炼函数

#### 示例一
我们看先一个示例，原始代码如下：
```java
void printOwing(double amout) {
  printBanner();
  // Print Details
  System.out.println("name:" + _name);
  System.out.println("amount:" + _amount);
}
```

**Extract Method** 的重构手法是将多个 `Println()` 抽离到独立的函数中（函数需要在命名上，下点功夫），这里对抽离的函数命名有 2 个建议：
- 保持函数尽可能的小，函数越小，被复用的可能性越大
- 良好的函数命名，可以让调用方的代码看起来上注释（结构清晰的代码，其实并不是很需要注释）

将 2 个 `Println()` 方法抽离到 `printDetails()` 函数中：
```java
void printDetails(double amount) {
  System.out.println("name:" + _name);
  System.out.println("amount:" + _amount);
}
```

当我们拥有 `printDetails()` 独立函数后，那么最终 `printOwing()` 函数看起来像：
```java
void printOwing(double amout) {
  printBanner();
  printDetails(double amount);
}
```

#### 示例二
示例一可能过于简单，无法表示 **Extract Method** 的奇妙能力，我们通过一个更复杂的案例来表示，代码如下：
```java
void printOwing() {
  Enumeration e = _orders.elements();
  double oustanding = 0.0

  // print banner
  System.out.println("*******************")
  System.out.println("***Customer Owes***")
  System.out.println("*******************")

  // calculate outstanding
  while(e.hasMoreElements()){
    Order each = (Order)e.nextElement();
    outstanding += each.getAmount();
  }

  // print details
  System.out.println("name:" + _name);
  System.out.println("amount:" + outstanding); 
}
```

首先审视一下这段代码，这是一段过长的函数（典型的糟糕代码的代表），因为它企图去完成所有的事情。但通过注释我们可以将它的函数提炼出来，方便函数复用，而且 printOwing() 代码结构也会更加清晰，最终版本如下：
```java
void printOwing(double previousAmount) {
  printBaner();   // Extract print banner
  double outstanding = getOutstanding(previousAmount * 1.2)   // Extract calculate outstanding
  printDetails(outstanding)   // print details
}
```

`printOwing()` 看起来像注释的代码，对于阅读非常友好，然后看看被 Extract Method 被提炼的函数代码：
```java
void printBanner() {
  System.out.println("*******************")
  System.out.println("***Customer Owes***")
  System.out.println("*******************")  
}

double getOutstanding(double initialValue) {
  double result = initialValue;   // 赋值引用对象，避免对引用传递
  Enumeration e = _orders.elements();
  while(e.hasMoreElements()){
    Order each = (Order)e.nextElement();
    result += each.getAmount();
  }
  return result;
}

void printDetails(double outstanding) {
  System.out.println("name:" + _name);
  System.out.println("amount:" + outstanding); 
}
```

#### 总结
提炼函数是最常用的重构手法之一，就是将过长函数按职责拆分至合理范围，这样被拆解的函数也有很大的概率被复用到其他函数内


### Inline Method 内联函数

当函数承担的职责和内容过小的时候，我们就需要将两个函数合并，**避免系统产生和分布过多的零散的函数**

#### 示例一
假如我们程序中有以下 2 个函数，示例程序：
```java
int getRating() {
  return (moreThanFiveLateDeliveries()) ? 2 : 1;
}

boolean moreThanFiveLateDeliveries() {
  return _numberOfLateDeliveries > 5;
}
```

`moreThanFiveLateDeliveries()` 似乎没有什么存在的必要，因为它仅仅是返回一个 `_numberOfLateDeliveries` 变量，我们就可以使用 **Inline Method 内联函数** 来重构它，修改后的代码如下：
```java
int getRating() {
  return (_numberOfLateDeliveries > 5) ? 2 : 1;
}
```
注意事项：
- 如果 `moreThanFiveLateDeliveries()` 已经被多个调用方引用，则不要去修改它

#### 总结
**Inline Method 内联函数** 就是逻辑和职责简单的，并且只被使用 1 次的函数进行合并和移除，让系统整体保持简单和整洁

### Inline Temp 内联临时变量
先看示例代码：
#### 示例一
```java
double basePrice = anOrder.basePrice();
return basePrice > 1000;
```

使用 **Inline Temp Variable** 来内联 basePrice 变量，代码如下：
```java
return anOrder.basePrice() > 1000;
```

#### 总结
如果函数内的临时变量，只被引用和使用一次，那么它就应该被内联和移除，避免产生过多冗余代码，影响阅读

### Replace Temp With Query 