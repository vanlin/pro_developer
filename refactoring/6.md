在重构的世界里，几乎所有的问题都源于过长的函数，因为：
- 过长的函数包含太多信息，承担太多职责，无法或者很难复用
- 错综复杂的逻辑，导致没人愿意去阅读代码，理解作者的意图

对于过长函数的处理方式，在 《重构》中作者推荐如下手法进行处理：

### Extract Method 提炼函数

#### 示例一
我们看先一个示例，原始代码如下：
```java
void printOwing(double amout) {
  printBanner();
  // Print Details
  System.out.println("name:" + _name);
  System.out.println("amount:" + _amount);
}
```

**Extract Method** 的重构手法是将多个 `Println()` 抽离到独立的函数中（函数需要在命名上，下点功夫），这里对抽离的函数命名有 2 个建议：
- 保持函数尽可能的小，函数越小，被复用的可能性越大
- 良好的函数命名，可以让调用方的代码看起来上注释（结构清晰的代码，其实并不是很需要注释）

将 2 个 `Println()` 方法抽离到 `printDetails()` 函数中：
```java
void printDetails(double amount) {
  System.out.println("name:" + _name);
  System.out.println("amount:" + _amount);
}
```

当我们拥有 `printDetails()` 独立函数后，那么最终 `printOwing()` 函数看起来像：
```java
void printOwing(double amout) {
  printBanner();
  printDetails(double amount);
}
```

#### 示例二
示例一可能过于简单，无法表示 **Extract Method** 的奇妙能力，我们通过一个更复杂的案例来表示，代码如下：
```java
void printOwing() {
  Enumeration e = _orders.elements();
  double oustanding = 0.0

  // print banner
  System.out.println("*******************")
  System.out.println("***Customer Owes***")
  System.out.println("*******************")

  // calculate outstanding
  while(e.hasMoreElements()){
    Order each = (Order)e.nextElement();
    outstanding += each.getAmount();
  }

  // print details
  System.out.println("name:" + _name);
  System.out.println("amount:" + outstanding); 
}
```

首先审视一下这段代码，这是一段过长的函数（典型的糟糕代码的代表），因为它企图去完成所有的事情。但通过注释我们可以将它的函数提炼出来，方便函数复用，而且 printOwing() 代码结构也会更加清晰：

```java

```