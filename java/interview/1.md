<!-- Java 基础相关，包含集合，多线程，JVM 相关题库 -->

### Java 基础

#### HashMap 的数据结构 ？
HashMap 的底层数据结构，在 JDK 1.8 前后分两种处理方式：
JDK 1.8 以前：
1. 是一个数据 + 链表的结构
2. 通过 hash 只判断当前元素存放的位置
3. 如果 hash 位置存在值，相同就会覆盖，不相同就会通过拉链法解决 hash 冲突

JDK 1.8 以前的 HashMap 的弊端：使用哈希攻击可以让 HashMap 性能退化至 O(n)

JDK 1.8 以后：
1. 当链表长度大于阈值（默认 8）时，会尝试将链表转为红黑树，减少搜索时间
2. JDK 1.8 对链表树化的原因就是避免大量重复 Hash 降低 HashMap 性能

注意：只有当 HashMap 数组大于 64 的情况下才会进行树化操作，否则只是执行 `resize()` 方法对数组进行扩容

#### HashMap 的扩容机制 ？
扩容机制如下：
1. 空参数实例化的 HashMap 默认内部数组是 null，第一次调用 put 方法时，则会开始第一次初始化扩容，长度为 16
2. 当元素超过阈值时变回触发扩容，每次扩容的容量都是之前容量的 2 倍
3. HashMap 的容量上限必须小于 1 << 30，既 1073741824 超过则不再增长，切阈值会被设置为 `Integer.MAX_VALUE`
4. 首次 PUT 时，先回触发扩容，然后存入数据，然后判断是否需要扩容




### Java 并发编程

#### ConcurrentHashMap 的存储结构 ？

这里分 JDK7，JDK8 两种情况：
* JDK 7：使用分段锁，也就是每一个 `Segment` 上同事只有一个线程可以操作，每一个 `Segment` 都是一个类似 HashMap 数组的结构，`Segment` 的个初始化就不能改变，默认 `Segment` 的个数是 16 个。
* JDK 8：使用的 Synchronized 所加 CAS 的机制。结构也进化为 Node 数组 + 链表/红黑树，Node 是类似于一个 HashEntry 的结构。


#### 线程池大小如何设置 ？
说明：N 为 CPU 的核心数
* CPU 密集型任务设置为 N + 1：多出来一个线程是为了防止线程偶发的缺页中断，或者其他原因导致的任务暂停而带来的影响
* I/O 密集型任务设置为 2N：线程在处理 I/O  的时间段内不会占用 CPU 来处理，因此可以多配置一些线程来处理

#### 多线程同步有哪些方法 ？
1. 最常用的是使用 `synchronized` 关键字
2. 对象锁使用 `wait` 和 `notify` 方法
3. 使用 `volatile` 保证变量的可见性
4. 使用 `ReentrantLock` 保证线程同步

#### 什么是重入锁（ReentrantLock）?
可以重复利用已经获取的锁资源，这种锁称为重入锁。意味着线程可以进入一个它已经拥有的锁所同步的代码块。  
注意：重复获取锁后，需要相同次数的 `unlock()` 才能解锁

#### 创建线程的三个方法是什么 ？
1. 通过集成 Thread 类创建线程类
2. 实现 Runnable 接口创建线程类
3. 通过 Callable 和 Future 接口创建线程

#### Java 怎么获取多线程的返回值 ？
1. 主线程等待
2. 使用 Thread 的 join 阻塞当前线程等待
3. 实现 Callable 接口（通过 FutureTask 或线程池的 Future）


#### 线程池有哪几种创建方式 ？
Java 1.5 以后 JUC 包提供的 `Executors` 提供四种线程池，分别为：
1. newCacheThreadPool：创建可缓存线程池
2. newFixedThreadPool：创建固定长度线程池，超出的线程会在队列中等待
3. newScheduledThreadPool：创建固定长度线程池，用于执行周期性任务
4. newSingleThreadExecutor：创建单线程池，用于执行需要保证顺序的任务

#### 线程池的参数有哪些

### Java VM 虚拟机

#### G1 收集器有哪些特点 ？
1. G1 名称是 Garbage-First，垃圾优先，特点是哪一块垃圾最多就有限清理它
2. G1 能利用 CPU，多核，并发环境来缩短 Stop The World 时间
3. G1 独立管理整个 GC 堆，还是保留了分代的概念
4. G1 维护一个优先列表，优先选择回收价值最大的 Region


#### 有哪些排查 OOM 的手段 ？
1. 增加启动参数：-XX:+HeapDumpOnOutOfMemoryError，-XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录
2. 同时可以使用 jstat （命令行工具）查看监控 JVM 的内存和 GC 情况，查看问题区域
3. 使用 MAT 工具载入 dump 文件，分析大对象的占用情况

#### 什么是堆内存，参数如何设置 ？
Java 中的堆内存主要是分配对象的存储空间，堆空间是所有线程共享访问的。  
设置堆参数有如下：
* -Xmx 指定堆的最大内存，这个内存不包括栈内存，也不包括堆外使用的内存
* -Xms 指定堆的初始化大小，专用服务器需要保持 -Xms 和 -Xmx 一致，否则启动会触发 Full GC，堆内存扩容也可能导致性能抖动
