<!-- Java 基础相关，包含集合，多线程，JVM 相关题库 -->

### Java 基础

#### HashMap 的数据结构 ？
HashMap 的底层数据结构，在 JDK 1.8 前后分两种处理方式：
JDK 1.8 以前：
1. 是一个数据 + 链表的结构
2. 通过 hash 只判断当前元素存放的位置
3. 如果 hash 位置存在值，相同就会覆盖，不相同就会通过拉链法解决 hash 冲突

JDK 1.8 以前的 HashMap 的弊端：使用哈希攻击可以让 HashMap 性能退化至 O(n)

JDK 1.8 以后：
1. 当链表长度大于阈值（默认 8）时，会尝试将链表转为红黑树，减少搜索时间
2. JDK 1.8 对链表树化的原因就是避免大量重复 Hash 降低 HashMap 性能

注意：只有当 HashMap 数组大于 64 的情况下才会进行树化操作，否则只是执行 `resize()` 方法对数组进行扩容

#### HashMap 的扩容机制 ？
扩容机制如下：
1. 空参数实例化的 HashMap 默认内部数组是 null，第一次调用 put 方法时，则会开始第一次初始化扩容，长度为 16
2. 当元素超过阈值时变回触发扩容，每次扩容的容量都是之前容量的 2 倍
3. HashMap 的容量上限必须小于 1 << 30，既 1073741824 超过则不再增长，切阈值会被设置为 `Integer.MAX_VALUE`
4. 首次 PUT 时，先回触发扩容，然后存入数据，然后判断是否需要扩容

#### Java 8 新特性有哪些了解 ？
1. 接口的默认方法
2. Lambda 表达式、函数式接口
3. 方法引用
4. Optional（NULL 包装类）
5. Streams 流、Parallel Streams 并行流
6. Date API（日期相关 API）



#### Lambda 表达式是什么？有什么优缺点？

Lambda 是 Java 8 的重要特性，也成为函数式编程，允许把一段匿名函数像方法参数一样进行传递，日常使用的优缺点如下：

优点：

1. 代码简洁
2. 减少匿名类的创建，节省系统资源
3. 节省不必要的接口和抽象函数

缺点：

1. 可读性差，出错不好调试
2. 没有学过 Lambda 的程序员基本看不懂



#### 修改对象的 equals 方法，使用 HashMap 存放对象的时候会有什么不同 ？

会调用被重载后的 equals 方法，原因是：

引用类型的 `equals()` 方法比较的是 **栈内存局部变量表中指向堆内存的指针的值** 是否相等。hashCode 返回对象实际内存地址的 hash 映射，没有重写前的 equals 方法和 `==` 运算符是等价的



#### 谈谈你对 String 的理解

1. String 是典型的不可变类，类和所有方法都被 final 修饰，所以关于修改 String 的操作都会生成新的 String 对象
2. Java 8 以前 String 是通过 `char` 数组来保存字符串，Java 9 以后貌似是通过 2 位 `byte[]` 来保存，更紧凑



关于 String 的知识点，先看代码：

```java
String a = "test";
String b = "test";
String c = new String("test");
```

* 变量 a，b 的 `test` 都是都想同一个对象，既 JVM 中字符串常量池中的 `test` 对象
* 变量 c 使用 `new` 关键字则会产生一个新的对象 test，该对象存储在堆中。
* a == b 为 TRUE 相等实际上是它们内存地址相等，并不是值相等，否则看看 a == c 为 FALSE 就知道了




---
### Java 并发编程

#### ConcurrentHashMap 的存储结构 ？

这里分 JDK7，JDK8 两种情况：
* JDK 7：使用分段锁，也就是每一个 `Segment` 上同事只有一个线程可以操作，每一个 `Segment` 都是一个类似 HashMap 数组的结构，`Segment` 的个初始化就不能改变，默认 `Segment` 的个数是 16 个。
* JDK 8：使用的 Synchronized 所加 CAS 的机制。结构也进化为 Node 数组 + 链表/红黑树，Node 是类似于一个 HashEntry 的结构。



#### ConcurrentHashMap 和 HashTable 的不同之处 ？

1. 实现方式不同，HashTable 只是在 HashTable 基础上加上 synchronized，而 ConcurrentHashMap 底层采用分段的数组 + 链表实现线程安全
2. ConcurrentHashMap 通过把 Map 分为 N 个 Segment，可以提供相同的线程安全，但是效率提升 N 倍，默认提升 16 倍，是大多数情况下线程安全的 HashMap 首选，副作用就是获取类似 `size()` 要获取全部的锁才能获取准确的值
3. 元素超过对应 Entry 数组长度的 75% 触发扩容，插入前才检测是否需要扩容，有效避免无效扩容




#### 线程池大小如何设置 ？
说明：N 为 CPU 的核心数
* CPU 密集型任务设置为 N + 1：多出来一个线程是为了防止线程偶发的缺页中断，或者其他原因导致的任务暂停而带来的影响
* I/O 密集型任务设置为 2N：线程在处理 I/O  的时间段内不会占用 CPU 来处理，因此可以多配置一些线程来处理

#### 多线程同步有哪些方法 ？
1. 最常用的是使用 `synchronized` 关键字
2. 对象锁使用 `wait` 和 `notify` 方法
3. 使用 `volatile` 保证变量的可见性
4. 使用 `ReentrantLock` 保证线程同步

#### 什么是重入锁（ReentrantLock）?
可以重复利用已经获取的锁资源，这种锁称为重入锁。意味着线程可以进入一个它已经拥有的锁所同步的代码块。  
注意：重复获取锁后，需要相同次数的 `unlock()` 才能解锁

#### 创建线程的三个方法是什么 ？
1. 通过集成 Thread 类创建线程类
2. 实现 Runnable 接口创建线程类
3. 通过 Callable 和 Future 接口创建线程

#### Java 怎么获取多线程的返回值 ？
1. 主线程等待
2. 使用 Thread 的 join 阻塞当前线程等待
3. 实现 Callable 接口（通过 FutureTask 或线程池的 Future）


#### 线程池有哪几种创建方式 ？
Java 1.5 以后 JUC 包提供的 `Executors` 提供四种线程池，分别为：
1. newCacheThreadPool：创建可缓存线程池
2. newFixedThreadPool：创建固定长度线程池，超出的线程会在队列中等待
3. newScheduledThreadPool：创建固定长度线程池，用于执行周期性任务
4. newSingleThreadExecutor：创建单线程池，用于执行需要保证顺序的任务

#### 线程池的参数有哪些
* corePoolSize 核心线程大小
* maximumPoolSize 最大线程数量
* keepAliveTime 线程空闲存活时间（通常配合 `unit` 存活时间单位使用）
* workQueue 工作队列
* threadFactory 线程工厂
* handler 拒绝策略

#### 线程池拒绝策略有哪些 ？
主要分四种：
1. AbortPolicy：丢弃任务并抛出 RejectedExecutionException 异常（默认策略）
2. DiscardPolicy：丢弃任务，但是不抛出异常
3. DiscardOldestPolicy：丢弃队列最老的任务，然后重新提交被拒绝的任务
4. CallerRunsPolicy：由调用线程处理该任务

#### 什么时候用多线程，为什么要设计多线程 ？

1. 需要短时间内处理大量任务的场景，多线程可以加快整体任务处理速度
2. 大任务，长阻塞，使用多线程可以增加系统的吞吐量，提高系统性能
3. 最大化利用 CPU 多核的性能，不会造成资源浪费

#### ThreadLocal 的实现原理？为什么要用 ThreadLocal ?
实现原理：
每个 Thread 线程内部都有一个 ThreadLocalMap；线程作为 key，泛型值作为 value，可以理解为线程级别的缓存。每一个线程都会获得一个单独的 map。ThreadLocal 提供 set 和 get 等访问方法，可以把变量绑定在线程上，是线程私有的变量，所有 get 总是返回由当前执行线程的最新值

ThreadLocal 主要解决 2 个问题：
1. 全局变量是所有线程共享，所以这些变量是不安全的，但是如果变量属于线程私有，那就不存在线程竞争，所有 ThreadLocal 变量天生就是线程安全的
2. 对于一些需要在上下文传递的参数变量，显示的声明变量会显得非常笨重和繁琐，假如可以绑定在 ThreadLocal 上面，可以让程序具备一些动态语言的特定，可以非常灵活，代码也可以简单很多



#### 线程和进程的区别

* 创建线程比较容易，创建新进程需要 `fork` 父进程
* 线程可以跟同一进程的其他线程通信，


---

### Java VM 虚拟机

#### G1 收集器有哪些特点 ？
1. G1 名称是 Garbage-First，垃圾优先，特点是哪一块垃圾最多就有限清理它
2. G1 能利用 CPU，多核，并发环境来缩短 Stop The World 时间
3. G1 独立管理整个 GC 堆，还是保留了分代的概念
4. G1 维护一个优先列表，优先选择回收价值最大的 Region


#### 有哪些排查 OOM 的手段 ？
1. 增加启动参数：-XX:+HeapDumpOnOutOfMemoryError，-XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录
2. 同时可以使用 jstat （命令行工具）查看监控 JVM 的内存和 GC 情况，查看问题区域
3. 使用 MAT 工具载入 dump 文件，分析大对象的占用情况

#### 什么是堆内存，参数如何设置 ？
Java 中的堆内存主要是分配对象的存储空间，堆空间是所有线程共享访问的。  
设置堆参数有如下：
* -Xmx 指定堆的最大内存，这个内存不包括栈内存，也不包括堆外使用的内存
* -Xms 指定堆的初始化大小，专用服务器需要保持 -Xms 和 -Xmx 一致，否则启动会触发 Full GC，堆内存扩容也可能导致性能抖动

#### 栈会溢出吗？方法区会溢出吗 ？
结论：栈会溢出。常见的栈异常有以下两种：
1. 因为栈是线程私有的，在线程调用方法的时候会在栈上创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。当线程创建的栈帧超过虚拟机允许的最大深度，虚拟机将会抛出 `StackOverFlowError` 异常，该异常出现在方法递归过深的情况。
2. Java 虚拟机的栈在动态扩展的时候无法申请到足够的内存，或者在新建线程的时候没有足够的内存，那么 Java 虚拟机会抛出 `OutOfMemoryError` 异常。

方法区在 Java 1.7 之前会溢出，原因如下：  
1. JDK 1.7 之前字符串常量池是方法区的一部分，例如常见 String 类的 `intern()` 方法使用不当就会导致方法区内存溢出，提供 PermGen space，但是在 Java 1.7 以后开始逐步移除永久代，所以就不会产生内存溢出。
2. 方法区用于存放 Class 的相关信息，如果动态生成大量的 Class 信息，也会产生内存异常。

#### JVM 如何加载类的 ？
JVM 类加载机制分为五个部分，如下：
1. 加载：从内存中生成一个代表这个类的对象
2. 验证：确保 Class 文件的字节流包含的信息符合虚拟机要求，不会危害虚拟机的安全
3. 准备：正式为类变量分配内存，并设置类变量的初始值阶段
4. 解析：将常量池中的符号引用替换为直接引用的过程
5. 初始化：JVM 完成加载，真正执行类中定义 Java 程序的代码



#### 哪些情况下的对象会被垃圾回收处理 ？

基于可达性分析算法，虚拟机会将一些对象定义为 GCRoots，从 GCRoots 出发沿着引用链向下寻找，如果对象不能通过 GCRoots 寻找到，虚拟机就认为该对象可以被回收掉。



追问：

如果对象不可达，一定会被垃圾收集器回收么 ？

答案：不一定，原因是：

1. 判断是否有必要执行的 `finalize()` 方法，对象重写 `finalize()` 方法且没有被运行过，暂时不会被回收 ♻️
2. 有必要执行的 `finalize()` 方法，JVM 会开一个线程去回收它们，只是对象最后一次的逃逸机会



