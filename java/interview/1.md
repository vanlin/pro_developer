<!-- Java 基础相关，包含集合，多线程，JVM 相关题库 -->

### Java 基础

#### HashMap 的数据结构 ？
HashMap 的底层数据结构，在 JDK 1.8 前后分两种处理方式：
JDK 1.8 以前：
1. 是一个数据 + 链表的结构
2. 通过 hash 只判断当前元素存放的位置
3. 如果 hash 位置存在值，相同就会覆盖，不相同就会通过拉链法解决 hash 冲突

JDK 1.8 以前的 HashMap 的弊端：使用哈希攻击可以让 HashMap 性能退化至 O(n)

JDK 1.8 以后：
1. 当链表长度大于阈值（默认 8）时，会尝试将链表转为红黑树，减少搜索时间
2. JDK 1.8 对链表树化的原因就是避免大量重复 Hash 降低 HashMap 性能

注意：只有当 HashMap 数组大于 64 的情况下才会进行树化操作，否则只是执行 `resize()` 方法对数组进行扩容

#### HashMap 的扩容机制 ？
扩容机制如下：
1. 空参数实例化的 HashMap 默认内部数组是 null，第一次调用 put 方法时，则会开始第一次初始化扩容，长度为 16
2. 当元素超过阈值时变回触发扩容，每次扩容的容量都是之前容量的 2 倍
3. HashMap 的容量上限必须小于 1 << 30，既 1073741824 超过则不再增长，切阈值会被设置为 `Integer.MAX_VALUE`
4. 首次 PUT 时，先回触发扩容，然后存入数据，然后判断是否需要扩容




### Java 并发

#### ConcurrentHashMap 的存储结构 ？

这里分 JDK7，JDK8 两种情况：
* JDK 7：使用分段锁，也就是每一个 `Segment` 上同事只有一个线程可以操作，每一个 `Segment` 都是一个类似 HashMap 数组的结构，`Segment` 的个初始化就不能改变，默认 `Segment` 的个数是 16 个。
* JDK 8：使用的 Synchronized 所加 CAS 的机制。结构也进化为 Node 数组 + 链表/红黑树，Node 是类似于一个 HashEntry 的结构。


#### 线程池大小如何设置 ？
说明：N 为 CPU 的核心数
* CPU 密集型任务设置为 N + 1：多出来一个线程是为了防止线程偶发的缺页中断，或者其他原因导致的任务暂停而带来的影响
* I/O 密集型任务设置为 2N：线程在处理 I/O  的时间段内不会占用 CPU 来处理，因此可以多配置一些线程来处理

### Java VM 虚拟机

