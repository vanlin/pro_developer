## Java 内存区域



### 运行时数据区域

Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域，各自区域有各自的用途，JVM 内存区域总览（如图）：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/D08bIm.png" alt="D08bIm" style="zoom:33%;" />

下面会讲解虚拟机各个区域的具体职责和功能划分



#### 程序计数器

程序计数器（Program Counter Register）是一块较小的内存空间

程序计数器的作用：

* 线程所执行的字节码的行号指示器
* 为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器
* 程序计数器占用的内存是线程私有的内存



#### 虚拟机栈 VM Stack

* 虚拟机栈描述的是 Java 方法执行的线程内存模型
* 每个方法被执行的时候虚拟机都会同步创建一个栈帧，保存局部变量表，操作数栈，动态链接等信息



虚拟机中常见两种内存区域异常有一个就来源于此，具体是：

* 线程请求的栈深度（方法调用）大于虚拟机所允许的深度，就会抛出 StackOverFlowError 异常
* 虚拟机内存容量可以动态扩容，当虚拟机无法申请到足够的内存就会抛出 OutOfMemoryError 异常



#### 本地方法栈

本地方法栈（Native Method Stack）类似 VM Stack（虚拟机栈），不同的是 VM Stack 服务对象是虚拟机执行的 Java 方法，而本地方法栈则是为虚拟机使用的本地方法（Native Method ）提供服务。

因为本地方法（Native Method）日常使用非常少，大多数的 Native Method 都是 Unsafe 操作，所以大概了解就好了。

另外需要注意的是本地方法栈区域同样会因为内存不足而抛出 StackOverFlowError 和 OutOfMemoryError 异常



####  堆空间 Heap

Java 堆空间的特点：

1. 堆空间 Heap 虚拟机所管理的最大的一块内存区域，被所有线程共享使用
2. Java 世界里面几乎所有的对象实例都在这里分配内存
3. Java GC 垃圾收集器重点关照的内存区域，所以堆是基于分代理论设计的，**但目前很多虚拟机已经不采用分代的设计了**
4. 堆空间的分代设计，还是细分的目的都是为了更好，更快的回收内存
5. 堆空间可以通过（-Xmx 和 -Xms 设定固定大小），但默认的实现是可扩展的，并且当堆空间无法再扩展内存的时候，虚拟机就会抛出 OutOfMemoryError 异常



新生代（一个 Eden 和两个 Survivor 区域）、老年代这种划分，历史上有许多款虚拟机采用这种设计，包括 HotSpot 和它的前身 Self、StrongTalk 虚拟机，源自 UC Berkeley 在 20 世纪 80 年代中期开发的 Berkeley Smalltalk



#### 方法区

方法区 Method Area 区域的特点：

1. 主要用于存储被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据
2. 跟堆 Heap 空间一样，是各个线程共享的内存区域



经常有人会把方法区和永久代混淆，两者完全是不同的概念，这里有必要解释一下：

永久代更容易导致内存溢出的问题，例如 String::intern()，所以JDK 8 完全废弃永久代的概念，在本地内存中实现元空间（Meta-Space）来代替。



方法区内部的运行时常量池的作用

* 用于存放编译期生成的各种字面量于符号引用
* 开发人员经常利用 String 类的 intern() 方法在运行时常量池缓存字符
* 当常量池无法再申请内存时会抛出 OutOfMemoryError 异常



#### 直接内存

Direct Memory 不属于虚拟机的一部分，但是如果频繁使用也会出现 OutOfMemoryError 异常，Direct Memory 的常见场景是在 JDK 1.4 中心加入的 NIO 类，它可以使用  Native 函数库直接分配堆外内存。



Direct Memory 的优缺点：

优点：直接分配内存不受 Java 堆大小的限制

缺点：容易被忽略，导致动态扩展的时候出现 OOM 异常



###  HotSpot 对象揭秘



#### 对象的创建过程

在语言层面创建对象仅仅是一个 `new` 关键字而已，但是在虚拟机中对象入如何创建的呢？

步骤如下：

1. 虚拟机遇到 `new` 指令的时候，首先在常量池中检查类的符号引用，检查类是否被加载，解析和初始化，如果没有则会先执行类的加载过程（我们假设类已经被加载，后续再探讨类的加载过程）
2.  