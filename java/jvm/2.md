### Java 内存区域



Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域，各自区域有各自的用途，JVM 内存区域总览（如图）：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/D08bIm.png" alt="D08bIm" style="zoom:33%;" />

下面会讲解虚拟机各个区域的具体职责和功能划分



#### 程序计数器

程序计数器（Program Counter Register）是一块较小的内存空间

程序计数器的作用：

* 线程所执行的字节码的行号指示器
* 为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器
* 程序计数器占用的内存是线程私有的内存



#### 虚拟机栈 VM Stack

* 虚拟机栈描述的是 Java 方法执行的线程内存模型
* 每个方法被执行的时候虚拟机都会同步创建一个栈帧，保存局部变量表，操作数栈，动态链接等信息



虚拟机中常见两种内存区域异常有一个就来源于此，具体是：

* 线程请求的栈深度（方法调用）大于虚拟机所允许的深度，就会抛出 StackOverFlowError 异常
* 虚拟机内存容量可以动态扩容，当虚拟机无法申请到足够的内存就会抛出 OutOfMemoryError 异常



#### 本地方法栈

本地方法栈（Native Method Stack）类似 VM Stack（虚拟机栈），不同的是 VM Stack 服务对象是虚拟机执行的 Java 方法，而本地方法栈则是为虚拟机使用的本地方法（Native Method ）提供服务。

因为本地方法（Native Method）日常使用非常少，大多数的 Native Method 都是 Unsafe 操作，所以大概了解就好了。

另外需要注意的是本地方法栈区域同样会因为内存不足而抛出 StackOverFlowError 和 OutOfMemoryError 异常



####  堆空间 Heap

Java 堆空间的特点：

* 堆空间 Heap 虚拟机所管理的最大的一块内存区域，被所有线程共享使用
* Java 世界里面几乎所有的对象实例都在这里分配内存
* Java GC 垃圾收集器重点关照的内存区域，所以堆是基于分代理论设计的，但目前很多虚拟机已经不采用分代的设计了
* 

